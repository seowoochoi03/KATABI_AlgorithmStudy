# 재귀 
✔ 하나의 함수에서 자신을 다시 호출해 작업을 수행하는 방식 <br/>
재귀함수를 호출하면, 함수의 매개변수, 지역변수, 리턴 값, 함수 종료 후 돌아가는 위치가 스택 메모리에 저장된다. 함수를 반복호출하므로 호출하는 횟수가 많아질수록 스택 메모리는 점점 커지게 되고, 결국에는 스택오버플로우가 발생할 수 있다. 

# 
#### `💕 재귀함수의 개념`
EX) 1부터 n까지의 합을 구하는 문제 <br/>

1. 재귀호출을 이용한 문제해결 알고리즘 <br/>
   (1) 1부터 4까지의 합은 1부터 3까지의 합에 4를 더하면 됩니다. <br/>
   (2) 1부터 3까지의 합은 1부터 2까지의 합에 3을 더하면 됩니다. <br/> 
   (3) 1부터 2까지의 합은 1부터 1까지의 합에 2를 더하면 됩니다.<br/>
   (4) 1부터 1까지의 합은 그냥 1입니다. <br/>

2. 알고리즘을 의사코드로 변환 <br/>
   [의사코드] 프로그래밍 언어가 아닌 일반적인 언어로 알고리즘을 표현한 코드 
   
   ```
   시작
      1. n이 1이 아니면, 1부터 (n-1)까지의 합에 n을 더한 값을 반환함. 
      2. n이 1이면, 그냥 1을 반환함. 
   끝
   ```
   
3. 재귀호출을 이용한 코드 작성 <br/>
   ```c
   int rSum(int n)
   {
       if (n == 1)           // n이 1이면, 그냥 1을 반환함.
       {
             return 1;
       }
       return n + rSum(n-1); // n이 1이 아니면, n을 1부터 (n-1)까지의 합과 더한 값을 반환함.
   }
   
   ```
#
#### `💕 재귀함수의 형식`
- 기본경우 : 함수가 재귀를 호출하지 않는 것 <br/>
- 재귀경우 : 자기자신을 호출해서 하위 작업을 수행하는 것 <br/>


#
#### `💕 재귀와 반복의 비교`
|  | 재귀 | 반복 |
|---|:---:|:---:|
| `종료` | 기본경우에 도달한 경우 | 조건이 거짓인 경우 |
| `부가공간` | 스택메모리에 부가공간 필요 | 부가공간 필요 X |
| `무한` | 메모리용량초과(스택오버플로우) | 추가메모리 존재 X (무한반복) |

#
#### `💕 재귀의 필요성`
효율성 측면에서는 반복해법 > 재귀해법 <br/>
→ 재귀는 메모리를 많이 차지하며 반복문에 비해 성능이 좋지 않기 때문 <br/> 

그렇다면, 성능이 좋지 않은 재귀함수를 사용하는 이유는? <br/> 
1. 변수 사용을 줄여줌 <br/>
   → 변수가 잡아먹는 메모리를 줄인다는 말 X <br/>
     변경가능한 상태를 제거해서 프로그램 오류 발생 가능성을 줄인다는 말 O <br/>
3. 가독성이 좋음 <br/>
   → 알고리즘 자체가 재귀적인 표현을 사용하기 자연스러울 때 <br/> 

#
#### `💕 꼬리재귀`
재귀 호출이 끝난 후 현재 함수에서 추가 연산을 요구하지 않도록 구현하는 형태의 재귀 <br/>
프로그래머가 꼬리재귀의 형태로 개발하고, 컴파일러가 꼬리 재귀 최적화를 지원한다면, <br/>
→ 일반 재귀의 성능저하, 스택오버플로우 발생 현상을 해결할 수 있음 <br/>



